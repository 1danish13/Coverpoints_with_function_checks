#######################################################################################################################################################################################################
# These coverpoints belongs to the test plan for RISC-V Privilege Arch Compliance developed by 10xEngineers
#######################################################################################################################################################################################################
     
misa:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*F.*D.*Zicsr.*); check is_implemented(misa) = True; check is_legal_warl(misa, 0x28, 0x28) = True;
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
	((write_val("misa") & 0x20) == 0) && (old_val("misa") & 0x28) == 0x28 && (misa & 0x28) == 0


misa_mxl_check_32:
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); check is_implemented(misa) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x01 : 0								# checks whether the mxl field of misa register is 1.
    
    
misa_mxl_check_64:
  config: 
    - check ISA:=regex(.*64.*); check ISA:=regex(.*I.*Zicsr.*); check is_implemented(misa) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x02 : 0								# checks whether the mxl field of misa register is 2.
    
    
misa_mxl_check_128:
  config: 
    - check ISA:=regex(.*128.*); check ISA:=regex(.*I.*Zicsr.*); check is_implemented(misa) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	misa >> (xlen-2) == 0x03 : 0								# checks whether the mxl field of misa register is 3.
		
	
misa_Umode:
  config: 
    - check ISA:=regex(.*I.*Zicsr.*U.*); check is_implemented(misa) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(misa >> 20) & 0x01 == 0x01 : 0 							# checking if U bit gets set if there is support for user mode RV32
	
	
misa_Smode:
  config: 
    - check ISA:=regex(.*I.*Zicsr.*S.*); check is_implemented(misa) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(misa >> 18) & 0x01 == 0x01 : 0 							# checking if S bit gets set if there is support for supervisor mode RV32
	
#######################################################################################################################################################################################################

mcause:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*Zicsr.*); 
    - check is_implemented_software(mcause) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	is_trap == True and (mcause >> 31) & 1 == 1 : 0							# checks if the exception or interrupt was an interrupt 
	is_trap == True and (mcause >> 31) & 1 == 0 : 0							# checks if the exception or interrupt was an exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h01 : 0				# Instruction access fault exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h02 : 0				# Illegal instruction exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h03 : 0				# Breakpoint exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h04 : 0				# Load address misaligned exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h05 : 0				# Load access fault exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h06 : 0				# Store/AMO address misaligned exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h07 : 0				# Store/AMO access fault exception
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h0b : 0				# Environment call from M-mode exception
	is_trap == True and (mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h03 : 0				# Machine software interrupt
	is_trap == True and (mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h07 : 0				# Machine timer interrupt
	is_trap == True and (mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h0b : 0				# Machine external interrupt
	
	
mcause_PageFault:
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*U.*); check satp.mode != "bare";	# checks if the satp.mode field, which determines the paging scheme, is implemented in software
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    (mcause & 0xff) == 0x0c || (mcause & 0xff) == 0x0d || (mcause & 0xff) == 0x0f) && is_trap == False : 0
	
	
mcause_PageFault_satp_bare:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*U.*); check satp.mode == "bare"; 
    - check is_implemented_software(mcause) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause & 0xff) == 0 : 0								# No page fault in bare mode


mcause_InstAddr_MissAligned:    
  config: 
    - check ISA:=regex(.*32.*); check ISA:=regex(.*I.*C.*Zicsr.*);
    - check is_implemented_software(mcause) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:							
	is_trap == True and (mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h00		# Instruction address misaligned exception, If C extension is present and enabled, the exception of instruction address misaligned cannot occur.


mcause_Smode:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*); 
    - check is_implemented_software(mcause) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h01 : 0				# Supervisor software interrupt
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h05 : 0				# Supervisor timer interrupt
	(mcause >> 31) & 1 == 1 && (mcause & 0xff) == 8'h09 : 0				# Supervisor external interrupt
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h09 : 0				# Environment call from S-mode exception

	
mcause_Umode:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*U.*); 
    - check is_implemented_software(mcause) = True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mcause >> 31) & 1 == 0 && (mcause & 0xff) == 8'h08 : 0				# Environment call from U-mode exception
	
	
#######################################################################################################################################################################################################

mstatus:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatus >> 3) & 0x01 == 0x01 : 0 							# checking if the MIE gets enabled
    	(mstatus >> 7) & 0x01 == 0x01 : 0 							# MPIE holds the value of the interrupt-enable bit active prior to the trap, checking whether it does that or not
    	(mstatus >> 21) & 0x1 == 0x00 : 0							# TW is set to 0 when there are no privilege levels below M.


mstatus_Smode:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatus >> 1) & 0x01 == 0x01 : 0							# Check that the SIE bit is set to 1 when the processor is in supervisor mode
	(mstatus >> 5) & 0x01 == 0x01 : 0 							# Check that the SPIE bit is set to 1 when interrupts are enabled in supervisor mode and that it is set to 0 when interrupts are disabled in supervisor mode 
	(mstatus >> 8) & 0x01 == 0x01 : 0 							# checks SPP bit
	(mstatus >> 22) & 0x1 == 0x01 : 0 							# When TSR=1, attempts to execute SRET while executing in S-mode will raise an illegal instruction exception.  
    	(mstatus >> 20) & 0x1 == 0x01 : 0 							# TVM=1, illegal instruction exception in S-mode
    	(mstatus >> 20) & 0x1 == 0x00 : 0 							# TVM=0, permitted in S-mode
    	(mstatus >> 21) & 0x1 == 0x01 : 0 							# When TW=1 and WFI is executed in a lower-privileged mode, it causes an illegal instruction exception if not completed within a bounded time limit, which may be 0
    	(mstatus >> 19) & 0x1 == 0x01 : 0 							# When MXR is set to 1, memory pages that are either marked as readable (R=1) or executable (X=1) can be loaded successfully.
    	(mstatus >> 19) & 0x1 == 0x00 : 0							# When MXR is set to 0, only loading data from pages that are marked as readable (with R=1) will be successful.
    	(mstatus >> 18) & 0x1 == 0x00 : 0							# SUM=0, S-mode memory accesses to pages accessible by U-mode will fault
    	(mstatus >> 18) & 0x1 == 0x01 : 0							# SUM=1, these accesses to pages accessible by U-mode are permitted
 	

mstatus_MPRV:
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*); check satp.mode != "bare"; 		# checks if the satp.mode field, which determines the paging scheme, is implemented in software and if there is additional privilege levels, except M.
    - check is_implemented_software(mstatus) = True; 					# checks if MPRV is present only if translation is allowed i.e S mode is present
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    (mstatus >> 17) & 0x1 == 0x01 : 0  							# When MPRV=1, load and store memory addresses are translated and protected, and endianness is applied

	
mstatus_MtoM:											# M-mode to M-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x3 : 0


mstatus_StoM:											# S-mode to M-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x3 and (mstatus >> 11) & 0x1 == 0x0 : 0


mstatus_UtoM:											# U-mode to M-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*U.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x3 and (mstatus >> 11) & 0x1 == 0x1 : 0


mstatus_MtoS:											# M-mode to S-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x1 : 0


mstatus_StoS:											# S-mode to S-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*);
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x1 and (mstatus >> 11) & 0x1 == 0x0 : 0


mstatus_UtoS:											# U-mode to S-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*U.*S.*); check is_trap = True;
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x1 and (mstatus >> 11) & 0x1 == 0x1 : 0


mstatus_MtoU:											# M-mode to U-mode transition
  config:
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*U.*); check is_trap = True;
  mnemonics:
    csrrw: 0
    csrrs: 0
  csr_comb:
    is_trap = True and (mstatus >> 10) & 0x3 == 0x0 : 0

	
mstatush:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 5) & 0x1 == 0x01 : 0							# checks if machine-mode byte enable (MBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that MBE is enabled
	

mstatus_little-endian:    
  config: 
    - check ISA:=regex(.*64.*); regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 5) & (mstatus >> 4) & (mstatus >> 6) == 0 : 0 				# checks if all three of these bits are set to 0, indicating that MBE, SBE, and UBE are all disabled. When these bits are all disabled, the processor is in little-endian mode, and accesses made to memory will be little-endian.


mstatus_big_endian:    
  config: 
    - check ISA:=regex(.*64.*); regex(.*I.*Zicsr.*S.*); check big_endian_support=True; 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatus >> 37) & 0x1 == 0x01 : 0 							# checks the sixth least significant bit of the upper 32 bits of the mstatus register to ensure that machine-mode byte enable (MBE) is set to enabled. If this bit is set to 1, the coverpoint will evaluate to 0, indicating that MBE is enabled 


mstatus_big_endian_Smode:    
  config: 
    - check ISA:=regex(.*64.*); regex(.*I.*Zicsr.*S.*); check big_endian_support=True; 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatush >> 4) & 0x1 == 0x01 : 0 							# ensures that certain instructions or operations are only executed when the processor is in supervisor mode and in big-endian mode						   
	
	
mstatus_big_endian__Umode:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*U.*); check big_endian_support=True;
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mstatus >> 6) & 0x1 == 0x01 : 0 							# check UBE = 1, it controls whether explicit load and store memory accesses made from U-mode is big-endian
	
	
mstatus_checking_SD:    
  config: 
    - check ISA:=regex(.*I.*Zicsr.*F.*V.*); 
  csr_comb: 
  	mstatus >> (xlen-1) == 1 && ((mstatus >> fs_shift) & fs_mask == fs_val) || ((mstatus >> vs_shift) & vs_mask == vs_val) : 0 	# The SD bit is read-only and is set when either the FS, VS bits encode a Dirty state 
    	mstatus >> (xlen-1) == 0 && ((mstatus >> fs_shift) & fs_mask == fs_val) || ((mstatus >> vs_shift) & vs_mask == vs_val) : 0 	# The SD bit is read-only and is set when either the FS, VS bits encode a Dirty state

    	
#######################################################################################################################################################################################################

mcycle:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcycle == 0x0 : 0					# where the value in mcycle register is 0
	mcycle > 1000 : 0 					# More than 1000 cycles were executed
	mcycle > 10000 : 0					# More than 10000 cycles were executed
	mcycle > 100000 : 0					# More than 100000 cycles were executed	

#######################################################################################################################################################################################################

mcounteren:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcounteren & 0x07 == 0x07 : 0				# checks that the three least significant bits are all 1
	mcounteren & 0x07 == 0x00 : 0				# checks that the three least significant bits are either all 0
    	mcounteren & 0x07 == 0x05 : 0				# for the next 3, checking that the three least significant bits are alternating 1s and 0s (e.g. 101, 010, or 011)

#######################################################################################################################################################################################################

mcountinhibit:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*);
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	mcountinhibit == 1 : 0					# checks that the value of the register is either 1
	mcountinhibit == 1 : 0					# checks that the value of the register is either 0
	mcountinhibit != 0 : 0					# checks that the value of the register is any value other than 0

#######################################################################################################################################################################################################
	
mepc:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x00 : 0 			# Exception or interrupt occurred at machine level (M-mode)
	(mepc & 0x3) == 0x00 : 0 				# Instruction was aligned on a 4-byte boundary
	(mepc & 0x3) == 0x01 : 0 				# Instruction was aligned on a 2-byte boundary
	(mepc & 0x3) == 0x02 : 0 				# Instruction was aligned on a 1-byte boundary
	(mepc & 0x3) == 0x03 : 0 				# Instruction was unaligned


mepc_Smode:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*S.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x01 : 0 			# Exception or interrupt occurred at supervisor level (S-mode)
	
mepc_Umode:    
  config: 
    - check ISA:=regex(.*32.*); regex(.*I.*Zicsr.*U.*); 
  mnemonics: 
    csrrw: 0
    csrrs: 0
  csr_comb:
	(mepc >> 3) & 0x07 == 0x02 : 0 			# Exception or interrupt occurred at user level (U-mode)

#######################################################################################################################################################################################################



